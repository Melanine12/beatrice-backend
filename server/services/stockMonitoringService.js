const { autoGenerateDemandeAffectationForStockHouseKeeping, calculateStockRestant } = require('../utils/autoGenerateDemandeAffectation');
const DispatchHousekeeping = require('../models/DispatchHousekeeping');
const DispatchHousekeepingArticle = require('../models/DispatchHousekeepingArticle');
const DemandeAffectation = require('../models/DemandeAffectation');
const DemandeAffectationLigne = require('../models/DemandeAffectationLigne');
const Inventaire = require('../models/Inventaire');
const Chambre = require('../models/Chambre');
const { Op } = require('sequelize');

class StockMonitoringService {
  constructor() {
    this.isMonitoring = false;
    this.monitoringInterval = null;
    this.checkInterval = 60000; // 1 minute par d√©faut
    this.lastCheckTime = null;
    this.processedArticles = new Set(); // Pour √©viter les doublons
  }

  /**
   * D√©marre le monitoring en temps r√©el
   * @param {number} intervalMs - Intervalle de v√©rification en millisecondes (d√©faut: 60000 = 1 minute)
   */
  startMonitoring(intervalMs = 60000) {
    if (this.isMonitoring) {
      console.log('‚ö†Ô∏è  Le monitoring est d√©j√† actif');
      return;
    }

    this.checkInterval = intervalMs;
    this.isMonitoring = true;
    console.log(`üöÄ D√©marrage du monitoring des stocks (intervalle: ${intervalMs / 1000}s)`);

    // V√©rification imm√©diate au d√©marrage
    this.checkStockLevels();

    // V√©rification p√©riodique
    this.monitoringInterval = setInterval(() => {
      this.checkStockLevels();
    }, this.checkInterval);
  }

  /**
   * Arr√™te le monitoring
   */
  stopMonitoring() {
    if (!this.isMonitoring) {
      return;
    }

    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }

    this.isMonitoring = false;
    console.log('üõë Arr√™t du monitoring des stocks');
  }

  /**
   * V√©rifie les niveaux de stock et g√©n√®re automatiquement les demandes si n√©cessaire
   */
  async checkStockLevels() {
    try {
      const startTime = Date.now();
      console.log('üîç V√©rification des niveaux de stock...');

      // Trouver l'espace "Stock House Keeping"
      const stockHousekeepingChambre = await Chambre.findOne({
        where: {
          [Op.or]: [
            { numero: 'Stock House Keeping' },
            { numero: 'Stock House keeping' },
            { numero: { [Op.like]: '%Stock House Keeping%' } }
          },
          type: 'Entrep√¥t'
        }
      });

      if (!stockHousekeepingChambre) {
        console.log('‚ùå Stock House Keeping espace non trouv√©');
        return;
      }

      // R√©cup√©rer tous les articles qui sont dans Stock House Keeping
      const demandesApprouvees = await DemandeAffectation.findAll({
        where: {
          statut: 'approuvee'
        },
        include: [
          {
            model: DemandeAffectationLigne,
            as: 'lignes',
            where: {
              chambre_id: stockHousekeepingChambre.id
            },
            include: [
              {
                model: Inventaire,
                as: 'inventaire',
                attributes: ['id', 'nom', 'code_produit', 'quantite_min', 'stock_minimum', 'categorie']
              }
            ]
          }
        ]
      });

      // Extraire les articles uniques
      const articlesMap = new Map();
      demandesApprouvees.forEach(demande => {
        demande.lignes.forEach(ligne => {
          if (ligne.inventaire && !articlesMap.has(ligne.inventaire.id)) {
            articlesMap.set(ligne.inventaire.id, {
              id: ligne.inventaire.id,
              nom: ligne.inventaire.nom,
              code_produit: ligne.inventaire.code_produit,
              quantite_min: ligne.inventaire.quantite_min || ligne.inventaire.stock_minimum || 0,
              stock_minimum: ligne.inventaire.stock_minimum || ligne.inventaire.quantite_min || 0,
              categorie: ligne.inventaire.categorie
            });
          }
        });
      });

      const articles = Array.from(articlesMap.values());

      if (articles.length === 0) {
        console.log('‚ÑπÔ∏è  Aucun article trouv√© dans Stock House Keeping');
        this.lastCheckTime = Date.now();
        return;
      }

      // V√©rifier chaque article
      const articlesEnRupture = [];
      for (const article of articles) {
        const stockRestant = await calculateStockRestant(article.id, stockHousekeepingChambre.id);
        const stockMinimum = parseFloat(article.quantite_min || article.stock_minimum || 0);

        // G√©n√©rer une demande si la quantit√© restante est <= stock minimum
        if (stockRestant <= stockMinimum) {
          articlesEnRupture.push({
            ...article,
            stock_restant: stockRestant,
            stock_minimum: stockMinimum
          });
        }
      }

      if (articlesEnRupture.length === 0) {
        const duration = Date.now() - startTime;
        console.log(`‚úÖ V√©rification termin√©e - Aucun article en rupture (${duration}ms)`);
        this.lastCheckTime = Date.now();
        return;
      }

      console.log(`‚ö†Ô∏è  ${articlesEnRupture.length} article(s) en rupture ou sous le seuil minimum d√©tect√©(s)`);

      // V√©rifier s'il existe d√©j√† une demande en attente pour ces articles
      const superviseurHousing = await require('../models/User').findOne({
        where: {
          role: 'Superviseur Housing',
          actif: true
        }
      });

      if (!superviseurHousing) {
        console.log('‚ùå Superviseur Housing non trouv√©');
        this.lastCheckTime = Date.now();
        return;
      }

      const articleIds = articlesEnRupture.map(a => a.id);
      const existingDemandes = await DemandeAffectation.findAll({
        where: {
          demandeur_id: superviseurHousing.id,
          statut: 'en_attente'
        },
        include: [
          {
            model: DemandeAffectationLigne,
            as: 'lignes',
            where: {
              inventaire_id: { [Op.in]: articleIds },
              chambre_id: stockHousekeepingChambre.id
            }
          }
        ]
      });

      // Filtrer les articles qui ont d√©j√† une demande en attente
      const articleIdsWithPendingDemande = new Set();
      existingDemandes.forEach(demande => {
        demande.lignes.forEach(ligne => {
          articleIdsWithPendingDemande.add(ligne.inventaire_id);
        });
      });

      const articlesToProcess = articlesEnRupture.filter(a => !articleIdsWithPendingDemande.has(a.id));

      if (articlesToProcess.length === 0) {
        const duration = Date.now() - startTime;
        console.log(`‚ÑπÔ∏è  Toutes les ruptures ont d√©j√† une demande en attente (${duration}ms)`);
        this.lastCheckTime = Date.now();
        return;
      }

      // G√©n√©rer la demande automatique
      await this.generateDemandeForArticles(articlesToProcess, stockHousekeepingChambre, superviseurHousing);

      const duration = Date.now() - startTime;
      console.log(`‚úÖ V√©rification termin√©e - ${articlesToProcess.length} demande(s) g√©n√©r√©e(s) (${duration}ms)`);
      this.lastCheckTime = Date.now();

    } catch (error) {
      console.error('‚ùå Erreur lors de la v√©rification des stocks:', error);
      this.lastCheckTime = Date.now();
    }
  }

  /**
   * G√©n√®re une demande d'affectation pour les articles en rupture
   */
  async generateDemandeForArticles(articles, stockHousekeepingChambre, superviseurHousing) {
    try {
      console.log(`üìù Cr√©ation d'une demande pour ${articles.length} article(s)...`);

      const demande = await DemandeAffectation.create({
        demandeur_id: superviseurHousing.id,
        statut: 'en_attente',
        commentaire: `Demande automatique g√©n√©r√©e suite √† une rupture de stock dans Stock House Keeping (quantit√© restante <= stock minimum)`
      });

      const lignes = articles.map(article => {
        const stockMinimum = parseFloat(article.stock_minimum || article.quantite_min || 0);
        // Quantit√© demand√©e = double du stock minimum
        const quantiteDemandee = Math.max(1, Math.ceil(stockMinimum * 2));

        console.log(`   - ${article.nom}: quantit√© restante = ${article.stock_restant}, stock min = ${stockMinimum}, quantit√© demand√©e = ${quantiteDemandee}`);

        return {
          demande_affectation_id: demande.id,
          inventaire_id: article.id,
          chambre_id: stockHousekeepingChambre.id,
          quantite_demandee: quantiteDemandee,
          quantite_approvee: 0
        };
      });

      await DemandeAffectationLigne.bulkCreate(lignes);

      console.log(`‚úÖ Demande d'affectation #${demande.id} cr√©√©e automatiquement pour ${articles.length} article(s)`);

      return {
        success: true,
        demande_id: demande.id,
        articles_count: articles.length
      };
    } catch (error) {
      console.error('‚ùå Erreur lors de la g√©n√©ration de la demande:', error);
      throw error;
    }
  }

  /**
   * V√©rifie un article sp√©cifique apr√®s un changement
   */
  async checkArticleAfterChange(articleId, chambreId) {
    try {
      // Trouver l'espace "Stock House Keeping"
      const stockHousekeepingChambre = await Chambre.findOne({
        where: {
          [Op.or]: [
            { numero: 'Stock House Keeping' },
            { numero: 'Stock House keeping' },
            { numero: { [Op.like]: '%Stock House Keeping%' } }
          },
          type: 'Entrep√¥t'
        }
      });

      if (!stockHousekeepingChambre || stockHousekeepingChambre.id !== chambreId) {
        return; // Pas dans Stock House Keeping
      }

      const inventaire = await Inventaire.findByPk(articleId);
      if (!inventaire) {
        return;
      }

      const stockRestant = await calculateStockRestant(articleId, chambreId);
      const stockMinimum = parseFloat(inventaire.quantite_min || inventaire.stock_minimum || 0);

      // Si la quantit√© restante est <= stock minimum, g√©n√©rer une demande
      if (stockRestant <= stockMinimum) {
        console.log(`‚ö†Ô∏è  Article ${inventaire.nom} (ID: ${articleId}) en rupture: ${stockRestant} <= ${stockMinimum}`);

        // V√©rifier s'il existe d√©j√† une demande en attente
        const superviseurHousing = await require('../models/User').findOne({
          where: {
            role: 'Superviseur Housing',
            actif: true
          }
        });

        if (!superviseurHousing) {
          console.log('‚ùå Superviseur Housing non trouv√©');
          return;
        }

        const existingDemande = await DemandeAffectation.findOne({
          where: {
            demandeur_id: superviseurHousing.id,
            statut: 'en_attente'
          },
          include: [
            {
              model: DemandeAffectationLigne,
              as: 'lignes',
              where: {
                inventaire_id: articleId,
                chambre_id: chambreId
              }
            }
          ]
        });

        if (existingDemande) {
          console.log(`‚ÑπÔ∏è  Une demande en attente existe d√©j√† pour l'article ${inventaire.nom}`);
          return;
        }

        // G√©n√©rer la demande
        await this.generateDemandeForArticles(
          [{
            id: inventaire.id,
            nom: inventaire.nom,
            code_produit: inventaire.code_produit,
            quantite_min: inventaire.quantite_min,
            stock_minimum: inventaire.stock_minimum || inventaire.quantite_min,
            categorie: inventaire.categorie,
            stock_restant: stockRestant
          }],
          stockHousekeepingChambre,
          superviseurHousing
        );
      }
    } catch (error) {
      console.error(`‚ùå Erreur lors de la v√©rification de l'article ${articleId}:`, error);
    }
  }

  /**
   * Obtient le statut du monitoring
   */
  getStatus() {
    return {
      isMonitoring: this.isMonitoring,
      checkInterval: this.checkInterval,
      lastCheckTime: this.lastCheckTime,
      nextCheckTime: this.lastCheckTime ? this.lastCheckTime + this.checkInterval : null
    };
  }
}

// Instance singleton
const stockMonitoringService = new StockMonitoringService();

module.exports = stockMonitoringService;

