const DemandeAffectation = require('../models/DemandeAffectation');
const DemandeAffectationLigne = require('../models/DemandeAffectationLigne');
const Inventaire = require('../models/Inventaire');
const Chambre = require('../models/Chambre');
const User = require('../models/User');
const DispatchHousekeeping = require('../models/DispatchHousekeeping');
const DispatchHousekeepingArticle = require('../models/DispatchHousekeepingArticle');
const { Op } = require('sequelize');

/**
 * Calcule la quantité restante d'un article dans Stock House Keeping
 * Quantité restante = quantite_approvee (depuis demandes d'affectation approuvées) - total dispatché
 */
async function calculateStockRestant(articleId, stockHousekeepingChambreId) {
  try {
    const inventaire = await Inventaire.findByPk(articleId);
    if (!inventaire) return 0;

    // Récupérer la quantité approuvée depuis les demandes d'affectation approuvées pour cette chambre
    
    const demandesApprouvees = await DemandeAffectation.findAll({
      where: {
        statut: 'approuvee'
      },
      include: [
        {
          model: DemandeAffectationLigne,
          as: 'lignes',
          where: {
            inventaire_id: articleId,
            chambre_id: stockHousekeepingChambreId
          },
          required: false
        }
      ]
    });

    // Calculer la quantité approuvée totale (stock actuel)
    let stockActuel = 0;
    demandesApprouvees.forEach(demande => {
      demande.lignes.forEach(ligne => {
        if (ligne.inventaire_id === articleId && ligne.chambre_id === stockHousekeepingChambreId) {
          stockActuel += parseInt(ligne.quantite_approvee || 0);
        }
      });
    });
    
    // Récupérer tous les dispatches pour calculer le total dispatché
    const dispatches = await DispatchHousekeeping.findAll({
      where: {
        statut: { [Op.in]: ['en_attente', 'en_cours', 'complete'] }
      },
      include: [
        {
          model: DispatchHousekeepingArticle,
          as: 'articles',
          where: { inventaire_id: articleId },
          required: false
        }
      ]
    });

    let totalDispatched = 0;
    dispatches.forEach(dispatch => {
      if (dispatch.articles && Array.isArray(dispatch.articles)) {
        dispatch.articles.forEach(art => {
          if (art.inventaire_id === articleId) {
            totalDispatched += parseInt(art.quantite || 0);
          }
        });
      }
    });

    // La quantité restante = stock actuel - total dispatché
    const stockRestant = Math.max(0, stockActuel - totalDispatched);
    
    return stockRestant;
  } catch (error) {
    console.error(`Error calculating stock restant for article ${articleId}:`, error);
    return 0;
  }
}

/**
 * Génère automatiquement des demandes d'affectation pour les articles en rupture
 * dans Stock House Keeping
 */
async function autoGenerateDemandeAffectationForStockHouseKeeping() {
  try {
    // 1. Trouver l'espace "Stock House Keeping" (type Entrepôt)
    const stockHousekeepingChambre = await Chambre.findOne({
      where: {
        [Op.or]: [
          { numero: 'Stock House Keeping' },
          { numero: 'Stock House keeping' },
          { numero: { [Op.like]: '%Stock House Keeping%' } }
        ],
        type: 'Entrepôt'
      }
    });

    if (!stockHousekeepingChambre) {
      console.log('Stock House Keeping espace non trouvé');
      return { success: false, message: 'Stock House Keeping espace non trouvé' };
    }

    // 2. Trouver un utilisateur Superviseur Housing
    const superviseurHousing = await User.findOne({
      where: {
        role: 'Superviseur Housing',
        actif: true
      }
    });

    if (!superviseurHousing) {
      console.log('Superviseur Housing non trouvé');
      return { success: false, message: 'Superviseur Housing non trouvé' };
    }

    // 3. Récupérer tous les articles qui sont dans Stock House Keeping
    // On va chercher les articles qui ont des demandes d'affectation approuvées vers cette chambre
    const demandesApprouvees = await DemandeAffectation.findAll({
      where: {
        statut: 'approuvee'
      },
      include: [
        {
          model: DemandeAffectationLigne,
          as: 'lignes',
          where: {
            chambre_id: stockHousekeepingChambre.id
          },
          include: [
            {
              model: Inventaire,
              as: 'inventaire',
              attributes: ['id', 'nom', 'code_produit', 'quantite_min', 'stock_minimum', 'categorie']
            }
          ]
        }
      ]
    });

    // Extraire les articles uniques
    const articlesMap = new Map();
    demandesApprouvees.forEach(demande => {
      demande.lignes.forEach(ligne => {
        if (ligne.inventaire && !articlesMap.has(ligne.inventaire.id)) {
          articlesMap.set(ligne.inventaire.id, {
            id: ligne.inventaire.id,
            nom: ligne.inventaire.nom,
            code_produit: ligne.inventaire.code_produit,
            quantite_min: ligne.inventaire.quantite_min,
            stock_minimum: ligne.inventaire.stock_minimum,
            categorie: ligne.inventaire.categorie
          });
        }
      });
    });

    const articles = Array.from(articlesMap.values());

    if (!articles || articles.length === 0) {
      return { success: true, message: 'Aucun article trouvé dans Stock House Keeping', demandes: [] };
    }

    // 4. Pour chaque article, calculer la quantité restante
    const articlesEnRupture = [];
    for (const article of articles) {
      const stockRestant = await calculateStockRestant(article.id, stockHousekeepingChambre.id);
      
      if (stockRestant === 0) {
        articlesEnRupture.push({
          ...article,
          stock_restant: stockRestant
        });
      }
    }

    if (articlesEnRupture.length === 0) {
      return { success: true, message: 'Aucun article en rupture', demandes: [] };
    }

    // 5. Vérifier s'il existe déjà une demande d'affectation en attente pour ces articles
    const articleIds = articlesEnRupture.map(a => a.id);
    const existingDemandes = await DemandeAffectation.findAll({
      where: {
        demandeur_id: superviseurHousing.id,
        statut: 'en_attente'
      },
      include: [
        {
          model: DemandeAffectationLigne,
          as: 'lignes',
          where: {
            inventaire_id: { [Op.in]: articleIds },
            chambre_id: stockHousekeepingChambre.id
          }
        }
      ]
    });

    // Filtrer les articles qui ont déjà une demande en attente
    const articleIdsWithPendingDemande = new Set();
    existingDemandes.forEach(demande => {
      demande.lignes.forEach(ligne => {
        articleIdsWithPendingDemande.add(ligne.inventaire_id);
      });
    });

    const articlesToProcess = articlesEnRupture.filter(a => !articleIdsWithPendingDemande.has(a.id));

    if (articlesToProcess.length === 0) {
      return { success: true, message: 'Toutes les ruptures ont déjà une demande en attente', demandes: [] };
    }

    // 6. Créer la demande d'affectation avec les articles en rupture
    const demande = await DemandeAffectation.create({
      demandeur_id: superviseurHousing.id,
      statut: 'en_attente',
      commentaire: 'Demande automatique générée suite à une rupture de stock dans Stock House Keeping'
    });

    // 7. Créer les lignes de la demande
    const lignes = articlesToProcess.map(article => {
      const stockMinimum = parseFloat(article.quantite_min || article.stock_minimum || 0);
      const quantiteDemandee = Math.max(1, Math.ceil(stockMinimum * 2)); // Double du stock minimum, minimum 1
      
      return {
        demande_affectation_id: demande.id,
        inventaire_id: article.id,
        chambre_id: stockHousekeepingChambre.id,
        quantite_demandee: quantiteDemandee,
        quantite_approvee: 0
      };
    });

    await DemandeAffectationLigne.bulkCreate(lignes);

    console.log(`✅ Demande d'affectation #${demande.id} créée automatiquement pour ${articlesToProcess.length} article(s) en rupture`);

    return {
      success: true,
      message: `Demande d'affectation #${demande.id} créée pour ${articlesToProcess.length} article(s)`,
      demande_id: demande.id,
      articles_count: articlesToProcess.length
    };
  } catch (error) {
    console.error('Error auto-generating demande affectation:', error);
    return { success: false, message: error.message };
  }
}

module.exports = {
  autoGenerateDemandeAffectationForStockHouseKeeping,
  calculateStockRestant
};

