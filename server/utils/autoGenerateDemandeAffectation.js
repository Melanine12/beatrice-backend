const DemandeAffectation = require('../models/DemandeAffectation');
const DemandeAffectationLigne = require('../models/DemandeAffectationLigne');
const Inventaire = require('../models/Inventaire');
const Chambre = require('../models/Chambre');
const User = require('../models/User');
const DispatchHousekeeping = require('../models/DispatchHousekeeping');
const DispatchHousekeepingArticle = require('../models/DispatchHousekeepingArticle');
const { Op } = require('sequelize');

/**
 * Calcule la quantit√© restante d'un article dans Stock House Keeping
 * Quantit√© restante = quantite_approvee (depuis demandes d'affectation approuv√©es) - total dispatch√©
 */
async function calculateStockRestant(articleId, stockHousekeepingChambreId) {
  try {
    const inventaire = await Inventaire.findByPk(articleId);
    if (!inventaire) return 0;

    // R√©cup√©rer la quantit√© approuv√©e depuis les demandes d'affectation approuv√©es pour cette chambre
    
    const demandesApprouvees = await DemandeAffectation.findAll({
      where: {
        statut: 'approuvee'
      },
      include: [
        {
          model: DemandeAffectationLigne,
          as: 'lignes',
          where: {
            inventaire_id: articleId,
            chambre_id: stockHousekeepingChambreId
          },
          required: false
        }
      ]
    });

    // Calculer la quantit√© approuv√©e totale (stock actuel)
    let stockActuel = 0;
    demandesApprouvees.forEach(demande => {
      demande.lignes.forEach(ligne => {
        if (ligne.inventaire_id === articleId && ligne.chambre_id === stockHousekeepingChambreId) {
          stockActuel += parseInt(ligne.quantite_approvee || 0);
        }
      });
    });
    
    // R√©cup√©rer tous les dispatches pour calculer le total dispatch√©
    const dispatches = await DispatchHousekeeping.findAll({
      where: {
        statut: { [Op.in]: ['en_attente', 'en_cours', 'complete'] }
      },
      include: [
        {
          model: DispatchHousekeepingArticle,
          as: 'articles',
          where: { inventaire_id: articleId },
          required: false
        }
      ]
    });

    let totalDispatched = 0;
    dispatches.forEach(dispatch => {
      if (dispatch.articles && Array.isArray(dispatch.articles)) {
        dispatch.articles.forEach(art => {
          if (art.inventaire_id === articleId) {
            totalDispatched += parseInt(art.quantite || 0);
          }
        });
      }
    });

    // La quantit√© restante = stock actuel - total dispatch√©
    const stockRestant = Math.max(0, stockActuel - totalDispatched);
    
    return stockRestant;
  } catch (error) {
    console.error(`Error calculating stock restant for article ${articleId}:`, error);
    return 0;
  }
}

/**
 * G√©n√®re automatiquement des demandes d'affectation pour les articles en rupture
 * dans Stock House Keeping
 */
async function autoGenerateDemandeAffectationForStockHouseKeeping() {
  try {
    console.log('üîç D√©but de la v√©rification automatique des ruptures...');
    
    // 1. Trouver l'espace "Stock House Keeping" (o√π on v√©rifie les ruptures)
    const stockHousekeepingChambre = await Chambre.findOne({
      where: {
        [Op.or]: [
          { numero: 'Stock House Keeping' },
          { numero: 'Stock House keeping' },
          { numero: { [Op.like]: '%Stock House Keeping%' } }
        ],
        type: 'Entrep√¥t'
      }
    });

    if (!stockHousekeepingChambre) {
      console.log('‚ùå Stock House Keeping espace non trouv√©');
      return { success: false, message: 'Stock House Keeping espace non trouv√©' };
    }
    
    console.log(`‚úÖ Espace source trouv√©: ${stockHousekeepingChambre.numero} (ID: ${stockHousekeepingChambre.id})`);

    // 1bis. Trouver l'espace "Stock House Keeping Entrepot" (destination pour les demandes)
    // Utiliser directement l'ID 244 (connu)
    let stockHousekeepingEntrepot = await Chambre.findByPk(244);
    
    // V√©rifier que c'est bien un Entrep√¥t
    if (!stockHousekeepingEntrepot || stockHousekeepingEntrepot.type !== 'Entrep√¥t') {
      // Si l'ID 244 n'existe pas ou n'est pas un Entrep√¥t, chercher par nom
      stockHousekeepingEntrepot = await Chambre.findOne({
        where: {
          [Op.or]: [
            { numero: 'Stock House Keeping Entrepot' },
            { numero: 'Stock House Keeping Entrep√¥t' },
            { numero: { [Op.like]: '%Stock House Keeping Entrepot%' } },
            { numero: { [Op.like]: '%Stock House Keeping Entrep√¥t%' } },
            { numero: { [Op.like]: '%Stock House Keeping%Entrepot%' } }
          ],
          type: 'Entrep√¥t'
        }
      });
    }

    if (!stockHousekeepingEntrepot) {
      console.log('‚ùå Stock House Keeping Entrepot (destination, ID 244) non trouv√©');
      return { success: false, message: 'Stock House Keeping Entrepot (destination, ID 244) non trouv√©' };
    }
    
    console.log(`‚úÖ Espace destination trouv√©: ${stockHousekeepingEntrepot.numero} (ID: ${stockHousekeepingEntrepot.id})`);

    // 2. Trouver un utilisateur Superviseur Housing
    const superviseurHousing = await User.findOne({
      where: {
        role: 'Superviseur Housing',
        actif: true
      }
    });

    if (!superviseurHousing) {
      console.log('‚ùå Superviseur Housing non trouv√©');
      return { success: false, message: 'Superviseur Housing non trouv√©' };
    }
    
    console.log(`‚úÖ Superviseur Housing trouv√©: ${superviseurHousing.prenom} ${superviseurHousing.nom} (ID: ${superviseurHousing.id})`);

    // 3. R√©cup√©rer tous les articles qui sont dans Stock House Keeping
    // Utiliser la m√™me logique que l'endpoint /chambres/:id/articles
    const MouvementStock = require('../models/MouvementStock');
    
    // R√©cup√©rer les demandes approuv√©es pour cette chambre
    const demandesApprouvees = await DemandeAffectation.findAll({
      where: {
        statut: 'approuvee'
      },
      include: [
        {
          model: DemandeAffectationLigne,
          as: 'lignes',
          where: {
            chambre_id: stockHousekeepingChambre.id
          },
          include: [
            {
              model: Inventaire,
              as: 'inventaire',
              attributes: ['id', 'nom', 'code_produit', 'quantite_min', 'categorie']
            }
          ]
        }
      ]
    });

    // R√©cup√©rer les mouvements de stock pour cette chambre
    const mouvements = await MouvementStock.findAll({
      where: {
        chambre_id: stockHousekeepingChambre.id,
        statut: 'Valid√©'
      },
      include: [
        {
          model: Inventaire,
          as: 'inventaire',
          attributes: ['id', 'nom', 'code_produit', 'quantite_min', 'categorie']
        }
      ]
    });

    // Extraire les articles uniques (priorit√© aux demandes approuv√©es)
    const articlesMap = new Map();
    
    // D'abord depuis les demandes approuv√©es
    demandesApprouvees.forEach(demande => {
      demande.lignes.forEach(ligne => {
        if (ligne.inventaire && !articlesMap.has(ligne.inventaire.id)) {
          articlesMap.set(ligne.inventaire.id, {
            id: ligne.inventaire.id,
            nom: ligne.inventaire.nom,
            code_produit: ligne.inventaire.code_produit,
            quantite_min: ligne.inventaire.quantite_min,
            stock_minimum: ligne.inventaire.quantite_min, // quantite_min est la colonne correcte
            categorie: ligne.inventaire.categorie
          });
        }
      });
    });

    // Ensuite depuis les mouvements de stock (pour les articles qui n'ont pas de demande approuv√©e)
    mouvements.forEach(mouvement => {
      if (mouvement.inventaire && !articlesMap.has(mouvement.inventaire.id)) {
          articlesMap.set(mouvement.inventaire.id, {
            id: mouvement.inventaire.id,
            nom: mouvement.inventaire.nom,
            code_produit: mouvement.inventaire.code_produit,
            quantite_min: mouvement.inventaire.quantite_min,
            stock_minimum: mouvement.inventaire.quantite_min, // quantite_min est la colonne correcte
            categorie: mouvement.inventaire.categorie
          });
      }
    });

    const articles = Array.from(articlesMap.values());

    if (!articles || articles.length === 0) {
      console.log('‚ÑπÔ∏è  Aucun article trouv√© dans Stock House Keeping');
      return { success: true, message: 'Aucun article trouv√© dans Stock House Keeping', demandes: [] };
    }

    console.log(`üì¶ ${articles.length} article(s) trouv√©(s) dans Stock House Keeping`);

    // 4. Pour chaque article, calculer la quantit√© restante
    const articlesEnRupture = [];
    for (const article of articles) {
      const stockRestant = await calculateStockRestant(article.id, stockHousekeepingChambre.id);
      const stockMinimum = parseFloat(article.quantite_min || 0);
      console.log(`   - ${article.nom}: quantit√© restante = ${stockRestant}, stock minimum = ${stockMinimum}`);
      
      // G√©n√©rer une demande si la quantit√© restante est 0 (rupture compl√®te)
      if (stockRestant === 0) {
        articlesEnRupture.push({
          ...article,
          stock_restant: stockRestant,
          stock_minimum: stockMinimum
        });
      }
    }

    if (articlesEnRupture.length === 0) {
      console.log('‚úÖ Aucun article en rupture');
      return { success: true, message: 'Aucun article en rupture', demandes: [] };
    }

    console.log(`‚ö†Ô∏è  ${articlesEnRupture.length} article(s) en rupture d√©tect√©(s)`);

    // 5. V√©rifier s'il existe d√©j√† une demande d'affectation en attente pour ces articles
    // V√©rifier TOUTES les demandes en attente pour cette destination, pas seulement celles du demandeur
    const articleIds = articlesEnRupture.map(a => a.id);
    const existingDemandes = await DemandeAffectation.findAll({
      where: {
        statut: 'en_attente'
      },
      include: [
        {
          model: DemandeAffectationLigne,
          as: 'lignes',
          where: {
            inventaire_id: { [Op.in]: articleIds },
            chambre_id: stockHousekeepingEntrepot.id // Destination: Stock House Keeping Entrepot
          },
          required: true // INNER JOIN pour ne prendre que les demandes qui ont des lignes correspondantes
        }
      ]
    });

    // Filtrer les articles qui ont d√©j√† une demande en attente (peu importe le demandeur)
    const articleIdsWithPendingDemande = new Set();
    existingDemandes.forEach(demande => {
      demande.lignes.forEach(ligne => {
        if (ligne.inventaire_id && articleIds.includes(ligne.inventaire_id)) {
          articleIdsWithPendingDemande.add(ligne.inventaire_id);
        }
      });
    });

    const articlesToProcess = articlesEnRupture.filter(a => !articleIdsWithPendingDemande.has(a.id));

    if (articlesToProcess.length === 0) {
      console.log('‚ÑπÔ∏è  Toutes les ruptures ont d√©j√† une demande en attente');
      return { success: true, message: 'Toutes les ruptures ont d√©j√† une demande en attente', demandes: [] };
    }

    console.log(`üìù Cr√©ation d'une demande pour ${articlesToProcess.length} article(s) en rupture...`);

    // 6. Cr√©er la demande d'affectation avec les articles en rupture dans une transaction
    // pour √©viter les doublons en cas d'appels simultan√©s
    const { sequelize } = require('../config/database');
    const articleIdsToProcess = articlesToProcess.map(a => a.id);
    const demande = await sequelize.transaction(async (t) => {
      // V√©rifier √† nouveau les doublons dans la transaction (protection contre les appels simultan√©s)
      const existingDemandesInTx = await DemandeAffectation.findAll({
        where: {
          statut: 'en_attente'
        },
        include: [
          {
            model: DemandeAffectationLigne,
            as: 'lignes',
            where: {
              inventaire_id: { [Op.in]: articleIdsToProcess },
              chambre_id: stockHousekeepingEntrepot.id
            },
            required: true
          }
        ],
        transaction: t
      });

      const articleIdsWithPendingDemandeInTx = new Set();
      existingDemandesInTx.forEach(demande => {
        demande.lignes.forEach(ligne => {
          if (ligne.inventaire_id && articleIdsToProcess.includes(ligne.inventaire_id)) {
            articleIdsWithPendingDemandeInTx.add(ligne.inventaire_id);
          }
        });
      });

      const articlesToProcessInTx = articlesToProcess.filter(a => !articleIdsWithPendingDemandeInTx.has(a.id));

      if (articlesToProcessInTx.length === 0) {
        console.log('‚ÑπÔ∏è  Toutes les ruptures ont d√©j√† une demande en attente (v√©rification transactionnelle)');
        return null; // Pas de demande √† cr√©er
      }

      // Cr√©er la demande
      const newDemande = await DemandeAffectation.create({
        demandeur_id: superviseurHousing.id,
        statut: 'en_attente',
        commentaire: 'Demande automatique g√©n√©r√©e suite √† une rupture de stock dans Stock House Keeping'
      }, { transaction: t });

      // 7. Cr√©er les lignes de la demande
      const lignes = articlesToProcessInTx.map(article => {
        const stockMinimum = parseFloat(article.quantite_min || 0);
        // Quantit√© demand√©e = double du stock minimum
        const quantiteDemandee = Math.max(1, Math.ceil(stockMinimum * 2));
        
        console.log(`   - ${article.nom}: quantit√© restante = ${article.stock_restant}, stock min = ${stockMinimum}, quantit√© demand√©e = ${quantiteDemandee} (2x stock min)`);
        
        return {
          demande_affectation_id: newDemande.id,
          inventaire_id: article.id,
          chambre_id: stockHousekeepingEntrepot.id, // Destination: Stock House Keeping Entrepot
          quantite_demandee: quantiteDemandee,
          quantite_approvee: 0
        };
      });

      await DemandeAffectationLigne.bulkCreate(lignes, { transaction: t });

      return { demande: newDemande, articlesCount: articlesToProcessInTx.length };
    });

    if (!demande) {
      return { success: true, message: 'Toutes les ruptures ont d√©j√† une demande en attente', demandes: [] };
    }

    console.log(`‚úÖ Demande d'affectation #${demande.demande.id} cr√©√©e automatiquement pour ${demande.articlesCount} article(s) en rupture`);

    return {
      success: true,
      message: `Demande d'affectation #${demande.demande.id} cr√©√©e pour ${demande.articlesCount} article(s)`,
      demande_id: demande.demande.id,
      articles_count: demande.articlesCount
    };
  } catch (error) {
    console.error('Error auto-generating demande affectation:', error);
    return { success: false, message: error.message };
  }
}

module.exports = {
  autoGenerateDemandeAffectationForStockHouseKeeping,
  calculateStockRestant
};

